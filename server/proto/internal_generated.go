// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package proto

import (
	"strconv"

	flatbuffers "github.com/google/flatbuffers/go"
)

type Op byte

const (
	Op_CREATE_PARTITION Op = 0
	Op_SHRINK_ISR       Op = 1
	Op_REPORT_LEADER    Op = 2
	Op_CHANGE_LEADER    Op = 3
	Op_EXPAND_ISR       Op = 4
)

var EnumNamesOp = map[Op]string{
	Op_CREATE_PARTITION: "CREATE_PARTITION",
	Op_SHRINK_ISR:       "SHRINK_ISR",
	Op_REPORT_LEADER:    "REPORT_LEADER",
	Op_CHANGE_LEADER:    "CHANGE_LEADER",
	Op_EXPAND_ISR:       "EXPAND_ISR",
}

var EnumValuesOp = map[string]Op{
	"CREATE_PARTITION": Op_CREATE_PARTITION,
	"SHRINK_ISR":       Op_SHRINK_ISR,
	"REPORT_LEADER":    Op_REPORT_LEADER,
	"CHANGE_LEADER":    Op_CHANGE_LEADER,
	"EXPAND_ISR":       Op_EXPAND_ISR,
}

func (v Op) String() string {
	if s, ok := EnumNamesOp[v]; ok {
		return s
	}
	return "Op(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ServerState struct {
	ServerID string
}

func ServerStatePack(builder *flatbuffers.Builder, t *ServerState) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	serverIDOffset := builder.CreateString(t.ServerID)
	ServerStateStart(builder)
	ServerStateAddServerID(builder, serverIDOffset)
	return ServerStateEnd(builder)
}

func (rcv *ServerStateReceiver) UnPackTo(t *ServerState) {
	t.ServerID = string(rcv.ServerID())
}

func (rcv *ServerStateReceiver) UnPack() *ServerState {
	if rcv == nil { return nil }
	t := &ServerState{}
	rcv.UnPackTo(t)
	return t
}

func (t *ServerState) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(ServerStatePack(b, t))
	return b.FinishedBytes(), nil
}

func (t *ServerState) Unmarshal(data []byte) error {
	GetRootAsServerStateReceiver(data, 0).UnPackTo(t)
	return nil
}

type ServerStateReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsServerStateReceiver(buf []byte, offset flatbuffers.UOffsetT) *ServerStateReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ServerStateReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ServerStateReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ServerStateReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ServerStateReceiver) ServerID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func ServerStateStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func ServerStateAddServerID(builder *flatbuffers.Builder, serverID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(serverID), 0)
}
func ServerStateEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type RaftLog struct {
	Op Op
	CreatePartitionOp *CreatePartitionOp
	ShrinkISROp *ShrinkISROp
	ChangeLeaderOp *ChangeLeaderOp
	ExpandISROp *ExpandISROp
}

func RaftLogPack(builder *flatbuffers.Builder, t *RaftLog) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	createPartitionOpOffset := CreatePartitionOpPack(builder, t.CreatePartitionOp)
	shrinkISROpOffset := ShrinkISROpPack(builder, t.ShrinkISROp)
	changeLeaderOpOffset := ChangeLeaderOpPack(builder, t.ChangeLeaderOp)
	expandISROpOffset := ExpandISROpPack(builder, t.ExpandISROp)
	RaftLogStart(builder)
	RaftLogAddOp(builder, t.Op)
	RaftLogAddCreatePartitionOp(builder, createPartitionOpOffset)
	RaftLogAddShrinkISROp(builder, shrinkISROpOffset)
	RaftLogAddChangeLeaderOp(builder, changeLeaderOpOffset)
	RaftLogAddExpandISROp(builder, expandISROpOffset)
	return RaftLogEnd(builder)
}

func (rcv *RaftLogReceiver) UnPackTo(t *RaftLog) {
	t.Op = rcv.Op()
	t.CreatePartitionOp = rcv.CreatePartitionOp(nil).UnPack()
	t.ShrinkISROp = rcv.ShrinkISROp(nil).UnPack()
	t.ChangeLeaderOp = rcv.ChangeLeaderOp(nil).UnPack()
	t.ExpandISROp = rcv.ExpandISROp(nil).UnPack()
}

func (rcv *RaftLogReceiver) UnPack() *RaftLog {
	if rcv == nil { return nil }
	t := &RaftLog{}
	rcv.UnPackTo(t)
	return t
}

func (t *RaftLog) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(RaftLogPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *RaftLog) Unmarshal(data []byte) error {
	GetRootAsRaftLogReceiver(data, 0).UnPackTo(t)
	return nil
}

type RaftLogReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsRaftLogReceiver(buf []byte, offset flatbuffers.UOffsetT) *RaftLogReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &RaftLogReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *RaftLogReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *RaftLogReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *RaftLogReceiver) Op() Op {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return Op(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *RaftLogReceiver) MutateOp(n Op) bool {
	return rcv._tab.MutateByteSlot(4, byte(n))
}

func (rcv *RaftLogReceiver) CreatePartitionOp(obj *CreatePartitionOpReceiver) *CreatePartitionOpReceiver {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(CreatePartitionOpReceiver)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *RaftLogReceiver) ShrinkISROp(obj *ShrinkISROpReceiver) *ShrinkISROpReceiver {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ShrinkISROpReceiver)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *RaftLogReceiver) ChangeLeaderOp(obj *ChangeLeaderOpReceiver) *ChangeLeaderOpReceiver {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ChangeLeaderOpReceiver)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *RaftLogReceiver) ExpandISROp(obj *ExpandISROpReceiver) *ExpandISROpReceiver {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ExpandISROpReceiver)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func RaftLogStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func RaftLogAddOp(builder *flatbuffers.Builder, op Op) {
	builder.PrependByteSlot(0, byte(op), 0)
}
func RaftLogAddCreatePartitionOp(builder *flatbuffers.Builder, createPartitionOp flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(createPartitionOp), 0)
}
func RaftLogAddShrinkISROp(builder *flatbuffers.Builder, shrinkISROp flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(shrinkISROp), 0)
}
func RaftLogAddChangeLeaderOp(builder *flatbuffers.Builder, changeLeaderOp flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(changeLeaderOp), 0)
}
func RaftLogAddExpandISROp(builder *flatbuffers.Builder, expandISROp flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(expandISROp), 0)
}
func RaftLogEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type CreatePartitionOp struct {
	Partition *Partition
}

func CreatePartitionOpPack(builder *flatbuffers.Builder, t *CreatePartitionOp) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	partitionOffset := PartitionPack(builder, t.Partition)
	CreatePartitionOpStart(builder)
	CreatePartitionOpAddPartition(builder, partitionOffset)
	return CreatePartitionOpEnd(builder)
}

func (rcv *CreatePartitionOpReceiver) UnPackTo(t *CreatePartitionOp) {
	t.Partition = rcv.Partition(nil).UnPack()
}

func (rcv *CreatePartitionOpReceiver) UnPack() *CreatePartitionOp {
	if rcv == nil { return nil }
	t := &CreatePartitionOp{}
	rcv.UnPackTo(t)
	return t
}

func (t *CreatePartitionOp) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(CreatePartitionOpPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *CreatePartitionOp) Unmarshal(data []byte) error {
	GetRootAsCreatePartitionOpReceiver(data, 0).UnPackTo(t)
	return nil
}

type CreatePartitionOpReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsCreatePartitionOpReceiver(buf []byte, offset flatbuffers.UOffsetT) *CreatePartitionOpReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CreatePartitionOpReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *CreatePartitionOpReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CreatePartitionOpReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *CreatePartitionOpReceiver) Partition(obj *PartitionReceiver) *PartitionReceiver {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(PartitionReceiver)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func CreatePartitionOpStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func CreatePartitionOpAddPartition(builder *flatbuffers.Builder, partition flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(partition), 0)
}
func CreatePartitionOpEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type CreatePartitionResponse struct {
}

func CreatePartitionResponsePack(builder *flatbuffers.Builder, t *CreatePartitionResponse) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	CreatePartitionResponseStart(builder)
	return CreatePartitionResponseEnd(builder)
}

func (rcv *CreatePartitionResponseReceiver) UnPackTo(t *CreatePartitionResponse) {
}

func (rcv *CreatePartitionResponseReceiver) UnPack() *CreatePartitionResponse {
	if rcv == nil { return nil }
	t := &CreatePartitionResponse{}
	rcv.UnPackTo(t)
	return t
}

func (t *CreatePartitionResponse) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(CreatePartitionResponsePack(b, t))
	return b.FinishedBytes(), nil
}

func (t *CreatePartitionResponse) Unmarshal(data []byte) error {
	GetRootAsCreatePartitionResponseReceiver(data, 0).UnPackTo(t)
	return nil
}

type CreatePartitionResponseReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsCreatePartitionResponseReceiver(buf []byte, offset flatbuffers.UOffsetT) *CreatePartitionResponseReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CreatePartitionResponseReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *CreatePartitionResponseReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CreatePartitionResponseReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func CreatePartitionResponseStart(builder *flatbuffers.Builder) {
	builder.StartObject(0)
}
func CreatePartitionResponseEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ShrinkISROp struct {
	Stream string
	Partition int32
	ReplicaToRemove string
	Leader string
	LeaderEpoch uint64
}

func ShrinkISROpPack(builder *flatbuffers.Builder, t *ShrinkISROp) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	streamOffset := builder.CreateString(t.Stream)
	replicaToRemoveOffset := builder.CreateString(t.ReplicaToRemove)
	leaderOffset := builder.CreateString(t.Leader)
	ShrinkISROpStart(builder)
	ShrinkISROpAddStream(builder, streamOffset)
	ShrinkISROpAddPartition(builder, t.Partition)
	ShrinkISROpAddReplicaToRemove(builder, replicaToRemoveOffset)
	ShrinkISROpAddLeader(builder, leaderOffset)
	ShrinkISROpAddLeaderEpoch(builder, t.LeaderEpoch)
	return ShrinkISROpEnd(builder)
}

func (rcv *ShrinkISROpReceiver) UnPackTo(t *ShrinkISROp) {
	t.Stream = string(rcv.Stream())
	t.Partition = rcv.Partition()
	t.ReplicaToRemove = string(rcv.ReplicaToRemove())
	t.Leader = string(rcv.Leader())
	t.LeaderEpoch = rcv.LeaderEpoch()
}

func (rcv *ShrinkISROpReceiver) UnPack() *ShrinkISROp {
	if rcv == nil { return nil }
	t := &ShrinkISROp{}
	rcv.UnPackTo(t)
	return t
}

func (t *ShrinkISROp) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(ShrinkISROpPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *ShrinkISROp) Unmarshal(data []byte) error {
	GetRootAsShrinkISROpReceiver(data, 0).UnPackTo(t)
	return nil
}

type ShrinkISROpReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsShrinkISROpReceiver(buf []byte, offset flatbuffers.UOffsetT) *ShrinkISROpReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ShrinkISROpReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ShrinkISROpReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ShrinkISROpReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ShrinkISROpReceiver) Stream() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ShrinkISROpReceiver) Partition() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ShrinkISROpReceiver) MutatePartition(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *ShrinkISROpReceiver) ReplicaToRemove() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ShrinkISROpReceiver) Leader() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ShrinkISROpReceiver) LeaderEpoch() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ShrinkISROpReceiver) MutateLeaderEpoch(n uint64) bool {
	return rcv._tab.MutateUint64Slot(12, n)
}

func ShrinkISROpStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func ShrinkISROpAddStream(builder *flatbuffers.Builder, stream flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(stream), 0)
}
func ShrinkISROpAddPartition(builder *flatbuffers.Builder, partition int32) {
	builder.PrependInt32Slot(1, partition, 0)
}
func ShrinkISROpAddReplicaToRemove(builder *flatbuffers.Builder, replicaToRemove flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(replicaToRemove), 0)
}
func ShrinkISROpAddLeader(builder *flatbuffers.Builder, leader flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(leader), 0)
}
func ShrinkISROpAddLeaderEpoch(builder *flatbuffers.Builder, leaderEpoch uint64) {
	builder.PrependUint64Slot(4, leaderEpoch, 0)
}
func ShrinkISROpEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ShrinkISRResponse struct {
}

func ShrinkISRResponsePack(builder *flatbuffers.Builder, t *ShrinkISRResponse) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	ShrinkISRResponseStart(builder)
	return ShrinkISRResponseEnd(builder)
}

func (rcv *ShrinkISRResponseReceiver) UnPackTo(t *ShrinkISRResponse) {
}

func (rcv *ShrinkISRResponseReceiver) UnPack() *ShrinkISRResponse {
	if rcv == nil { return nil }
	t := &ShrinkISRResponse{}
	rcv.UnPackTo(t)
	return t
}

func (t *ShrinkISRResponse) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(ShrinkISRResponsePack(b, t))
	return b.FinishedBytes(), nil
}

func (t *ShrinkISRResponse) Unmarshal(data []byte) error {
	GetRootAsShrinkISRResponseReceiver(data, 0).UnPackTo(t)
	return nil
}

type ShrinkISRResponseReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsShrinkISRResponseReceiver(buf []byte, offset flatbuffers.UOffsetT) *ShrinkISRResponseReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ShrinkISRResponseReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ShrinkISRResponseReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ShrinkISRResponseReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func ShrinkISRResponseStart(builder *flatbuffers.Builder) {
	builder.StartObject(0)
}
func ShrinkISRResponseEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ExpandISROp struct {
	Stream string
	Partition int32
	ReplicaToAdd string
	Leader string
	LeaderEpoch uint64
}

func ExpandISROpPack(builder *flatbuffers.Builder, t *ExpandISROp) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	streamOffset := builder.CreateString(t.Stream)
	replicaToAddOffset := builder.CreateString(t.ReplicaToAdd)
	leaderOffset := builder.CreateString(t.Leader)
	ExpandISROpStart(builder)
	ExpandISROpAddStream(builder, streamOffset)
	ExpandISROpAddPartition(builder, t.Partition)
	ExpandISROpAddReplicaToAdd(builder, replicaToAddOffset)
	ExpandISROpAddLeader(builder, leaderOffset)
	ExpandISROpAddLeaderEpoch(builder, t.LeaderEpoch)
	return ExpandISROpEnd(builder)
}

func (rcv *ExpandISROpReceiver) UnPackTo(t *ExpandISROp) {
	t.Stream = string(rcv.Stream())
	t.Partition = rcv.Partition()
	t.ReplicaToAdd = string(rcv.ReplicaToAdd())
	t.Leader = string(rcv.Leader())
	t.LeaderEpoch = rcv.LeaderEpoch()
}

func (rcv *ExpandISROpReceiver) UnPack() *ExpandISROp {
	if rcv == nil { return nil }
	t := &ExpandISROp{}
	rcv.UnPackTo(t)
	return t
}

func (t *ExpandISROp) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(ExpandISROpPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *ExpandISROp) Unmarshal(data []byte) error {
	GetRootAsExpandISROpReceiver(data, 0).UnPackTo(t)
	return nil
}

type ExpandISROpReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsExpandISROpReceiver(buf []byte, offset flatbuffers.UOffsetT) *ExpandISROpReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ExpandISROpReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ExpandISROpReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ExpandISROpReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ExpandISROpReceiver) Stream() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ExpandISROpReceiver) Partition() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExpandISROpReceiver) MutatePartition(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *ExpandISROpReceiver) ReplicaToAdd() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ExpandISROpReceiver) Leader() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ExpandISROpReceiver) LeaderEpoch() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExpandISROpReceiver) MutateLeaderEpoch(n uint64) bool {
	return rcv._tab.MutateUint64Slot(12, n)
}

func ExpandISROpStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func ExpandISROpAddStream(builder *flatbuffers.Builder, stream flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(stream), 0)
}
func ExpandISROpAddPartition(builder *flatbuffers.Builder, partition int32) {
	builder.PrependInt32Slot(1, partition, 0)
}
func ExpandISROpAddReplicaToAdd(builder *flatbuffers.Builder, replicaToAdd flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(replicaToAdd), 0)
}
func ExpandISROpAddLeader(builder *flatbuffers.Builder, leader flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(leader), 0)
}
func ExpandISROpAddLeaderEpoch(builder *flatbuffers.Builder, leaderEpoch uint64) {
	builder.PrependUint64Slot(4, leaderEpoch, 0)
}
func ExpandISROpEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ExpandISRResponse struct {
}

func ExpandISRResponsePack(builder *flatbuffers.Builder, t *ExpandISRResponse) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	ExpandISRResponseStart(builder)
	return ExpandISRResponseEnd(builder)
}

func (rcv *ExpandISRResponseReceiver) UnPackTo(t *ExpandISRResponse) {
}

func (rcv *ExpandISRResponseReceiver) UnPack() *ExpandISRResponse {
	if rcv == nil { return nil }
	t := &ExpandISRResponse{}
	rcv.UnPackTo(t)
	return t
}

func (t *ExpandISRResponse) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(ExpandISRResponsePack(b, t))
	return b.FinishedBytes(), nil
}

func (t *ExpandISRResponse) Unmarshal(data []byte) error {
	GetRootAsExpandISRResponseReceiver(data, 0).UnPackTo(t)
	return nil
}

type ExpandISRResponseReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsExpandISRResponseReceiver(buf []byte, offset flatbuffers.UOffsetT) *ExpandISRResponseReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ExpandISRResponseReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ExpandISRResponseReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ExpandISRResponseReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func ExpandISRResponseStart(builder *flatbuffers.Builder) {
	builder.StartObject(0)
}
func ExpandISRResponseEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ReportLeaderOp struct {
	Stream string
	Partition int32
	Replica string
	Leader string
	LeaderEpoch uint64
}

func ReportLeaderOpPack(builder *flatbuffers.Builder, t *ReportLeaderOp) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	streamOffset := builder.CreateString(t.Stream)
	replicaOffset := builder.CreateString(t.Replica)
	leaderOffset := builder.CreateString(t.Leader)
	ReportLeaderOpStart(builder)
	ReportLeaderOpAddStream(builder, streamOffset)
	ReportLeaderOpAddPartition(builder, t.Partition)
	ReportLeaderOpAddReplica(builder, replicaOffset)
	ReportLeaderOpAddLeader(builder, leaderOffset)
	ReportLeaderOpAddLeaderEpoch(builder, t.LeaderEpoch)
	return ReportLeaderOpEnd(builder)
}

func (rcv *ReportLeaderOpReceiver) UnPackTo(t *ReportLeaderOp) {
	t.Stream = string(rcv.Stream())
	t.Partition = rcv.Partition()
	t.Replica = string(rcv.Replica())
	t.Leader = string(rcv.Leader())
	t.LeaderEpoch = rcv.LeaderEpoch()
}

func (rcv *ReportLeaderOpReceiver) UnPack() *ReportLeaderOp {
	if rcv == nil { return nil }
	t := &ReportLeaderOp{}
	rcv.UnPackTo(t)
	return t
}

func (t *ReportLeaderOp) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(ReportLeaderOpPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *ReportLeaderOp) Unmarshal(data []byte) error {
	GetRootAsReportLeaderOpReceiver(data, 0).UnPackTo(t)
	return nil
}

type ReportLeaderOpReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsReportLeaderOpReceiver(buf []byte, offset flatbuffers.UOffsetT) *ReportLeaderOpReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ReportLeaderOpReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ReportLeaderOpReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ReportLeaderOpReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ReportLeaderOpReceiver) Stream() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ReportLeaderOpReceiver) Partition() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ReportLeaderOpReceiver) MutatePartition(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *ReportLeaderOpReceiver) Replica() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ReportLeaderOpReceiver) Leader() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ReportLeaderOpReceiver) LeaderEpoch() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ReportLeaderOpReceiver) MutateLeaderEpoch(n uint64) bool {
	return rcv._tab.MutateUint64Slot(12, n)
}

func ReportLeaderOpStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func ReportLeaderOpAddStream(builder *flatbuffers.Builder, stream flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(stream), 0)
}
func ReportLeaderOpAddPartition(builder *flatbuffers.Builder, partition int32) {
	builder.PrependInt32Slot(1, partition, 0)
}
func ReportLeaderOpAddReplica(builder *flatbuffers.Builder, replica flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(replica), 0)
}
func ReportLeaderOpAddLeader(builder *flatbuffers.Builder, leader flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(leader), 0)
}
func ReportLeaderOpAddLeaderEpoch(builder *flatbuffers.Builder, leaderEpoch uint64) {
	builder.PrependUint64Slot(4, leaderEpoch, 0)
}
func ReportLeaderOpEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ReportLeaderResponse struct {
}

func ReportLeaderResponsePack(builder *flatbuffers.Builder, t *ReportLeaderResponse) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	ReportLeaderResponseStart(builder)
	return ReportLeaderResponseEnd(builder)
}

func (rcv *ReportLeaderResponseReceiver) UnPackTo(t *ReportLeaderResponse) {
}

func (rcv *ReportLeaderResponseReceiver) UnPack() *ReportLeaderResponse {
	if rcv == nil { return nil }
	t := &ReportLeaderResponse{}
	rcv.UnPackTo(t)
	return t
}

func (t *ReportLeaderResponse) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(ReportLeaderResponsePack(b, t))
	return b.FinishedBytes(), nil
}

func (t *ReportLeaderResponse) Unmarshal(data []byte) error {
	GetRootAsReportLeaderResponseReceiver(data, 0).UnPackTo(t)
	return nil
}

type ReportLeaderResponseReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsReportLeaderResponseReceiver(buf []byte, offset flatbuffers.UOffsetT) *ReportLeaderResponseReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ReportLeaderResponseReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ReportLeaderResponseReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ReportLeaderResponseReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func ReportLeaderResponseStart(builder *flatbuffers.Builder) {
	builder.StartObject(0)
}
func ReportLeaderResponseEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ChangeLeaderOp struct {
	Stream string
	Partition int32
	Leader string
}

func ChangeLeaderOpPack(builder *flatbuffers.Builder, t *ChangeLeaderOp) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	streamOffset := builder.CreateString(t.Stream)
	leaderOffset := builder.CreateString(t.Leader)
	ChangeLeaderOpStart(builder)
	ChangeLeaderOpAddStream(builder, streamOffset)
	ChangeLeaderOpAddPartition(builder, t.Partition)
	ChangeLeaderOpAddLeader(builder, leaderOffset)
	return ChangeLeaderOpEnd(builder)
}

func (rcv *ChangeLeaderOpReceiver) UnPackTo(t *ChangeLeaderOp) {
	t.Stream = string(rcv.Stream())
	t.Partition = rcv.Partition()
	t.Leader = string(rcv.Leader())
}

func (rcv *ChangeLeaderOpReceiver) UnPack() *ChangeLeaderOp {
	if rcv == nil { return nil }
	t := &ChangeLeaderOp{}
	rcv.UnPackTo(t)
	return t
}

func (t *ChangeLeaderOp) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(ChangeLeaderOpPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *ChangeLeaderOp) Unmarshal(data []byte) error {
	GetRootAsChangeLeaderOpReceiver(data, 0).UnPackTo(t)
	return nil
}

type ChangeLeaderOpReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsChangeLeaderOpReceiver(buf []byte, offset flatbuffers.UOffsetT) *ChangeLeaderOpReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ChangeLeaderOpReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ChangeLeaderOpReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ChangeLeaderOpReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ChangeLeaderOpReceiver) Stream() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ChangeLeaderOpReceiver) Partition() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ChangeLeaderOpReceiver) MutatePartition(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *ChangeLeaderOpReceiver) Leader() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func ChangeLeaderOpStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func ChangeLeaderOpAddStream(builder *flatbuffers.Builder, stream flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(stream), 0)
}
func ChangeLeaderOpAddPartition(builder *flatbuffers.Builder, partition int32) {
	builder.PrependInt32Slot(1, partition, 0)
}
func ChangeLeaderOpAddLeader(builder *flatbuffers.Builder, leader flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(leader), 0)
}
func ChangeLeaderOpEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Partition struct {
	Subject string
	Stream string
	Id int32
	Group string
	ReplicationFactor int32
	Replicas []string
	Leader string
	Isr []string
	LeaderEpoch uint64
	Epoch uint64
}

func PartitionPack(builder *flatbuffers.Builder, t *Partition) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	subjectOffset := builder.CreateString(t.Subject)
	streamOffset := builder.CreateString(t.Stream)
	groupOffset := builder.CreateString(t.Group)
	replicasOffset := flatbuffers.UOffsetT(0)
	if t.Replicas != nil {
		replicasLength := len(t.Replicas)
		replicasOffsets := make([]flatbuffers.UOffsetT, replicasLength)
		for j := 0; j < replicasLength; j++ {
			replicasOffsets[j] = builder.CreateString(t.Replicas[j])
		}
		PartitionStartReplicasVector(builder, replicasLength)
		for j := replicasLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(replicasOffsets[j])
		}
		replicasOffset = builder.EndVector(replicasLength)
	}
	leaderOffset := builder.CreateString(t.Leader)
	isrOffset := flatbuffers.UOffsetT(0)
	if t.Isr != nil {
		isrLength := len(t.Isr)
		isrOffsets := make([]flatbuffers.UOffsetT, isrLength)
		for j := 0; j < isrLength; j++ {
			isrOffsets[j] = builder.CreateString(t.Isr[j])
		}
		PartitionStartIsrVector(builder, isrLength)
		for j := isrLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(isrOffsets[j])
		}
		isrOffset = builder.EndVector(isrLength)
	}
	PartitionStart(builder)
	PartitionAddSubject(builder, subjectOffset)
	PartitionAddStream(builder, streamOffset)
	PartitionAddId(builder, t.Id)
	PartitionAddGroup(builder, groupOffset)
	PartitionAddReplicationFactor(builder, t.ReplicationFactor)
	PartitionAddReplicas(builder, replicasOffset)
	PartitionAddLeader(builder, leaderOffset)
	PartitionAddIsr(builder, isrOffset)
	PartitionAddLeaderEpoch(builder, t.LeaderEpoch)
	PartitionAddEpoch(builder, t.Epoch)
	return PartitionEnd(builder)
}

func (rcv *PartitionReceiver) UnPackTo(t *Partition) {
	t.Subject = string(rcv.Subject())
	t.Stream = string(rcv.Stream())
	t.Id = rcv.Id()
	t.Group = string(rcv.Group())
	t.ReplicationFactor = rcv.ReplicationFactor()
	replicasLength := rcv.ReplicasLength()
	t.Replicas = make([]string, replicasLength)
	for j := 0; j < replicasLength; j++ {
		t.Replicas[j] = string(rcv.Replicas(j))
	}
	t.Leader = string(rcv.Leader())
	isrLength := rcv.IsrLength()
	t.Isr = make([]string, isrLength)
	for j := 0; j < isrLength; j++ {
		t.Isr[j] = string(rcv.Isr(j))
	}
	t.LeaderEpoch = rcv.LeaderEpoch()
	t.Epoch = rcv.Epoch()
}

func (rcv *PartitionReceiver) UnPack() *Partition {
	if rcv == nil { return nil }
	t := &Partition{}
	rcv.UnPackTo(t)
	return t
}

func (t *Partition) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(PartitionPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *Partition) Unmarshal(data []byte) error {
	GetRootAsPartitionReceiver(data, 0).UnPackTo(t)
	return nil
}

type PartitionReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsPartitionReceiver(buf []byte, offset flatbuffers.UOffsetT) *PartitionReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PartitionReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *PartitionReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PartitionReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *PartitionReceiver) Subject() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *PartitionReceiver) Stream() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *PartitionReceiver) Id() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *PartitionReceiver) MutateId(n int32) bool {
	return rcv._tab.MutateInt32Slot(8, n)
}

func (rcv *PartitionReceiver) Group() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *PartitionReceiver) ReplicationFactor() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *PartitionReceiver) MutateReplicationFactor(n int32) bool {
	return rcv._tab.MutateInt32Slot(12, n)
}

func (rcv *PartitionReceiver) Replicas(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *PartitionReceiver) ReplicasLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *PartitionReceiver) Leader() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *PartitionReceiver) Isr(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *PartitionReceiver) IsrLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *PartitionReceiver) LeaderEpoch() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *PartitionReceiver) MutateLeaderEpoch(n uint64) bool {
	return rcv._tab.MutateUint64Slot(20, n)
}

func (rcv *PartitionReceiver) Epoch() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *PartitionReceiver) MutateEpoch(n uint64) bool {
	return rcv._tab.MutateUint64Slot(22, n)
}

func PartitionStart(builder *flatbuffers.Builder) {
	builder.StartObject(10)
}
func PartitionAddSubject(builder *flatbuffers.Builder, subject flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(subject), 0)
}
func PartitionAddStream(builder *flatbuffers.Builder, stream flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(stream), 0)
}
func PartitionAddId(builder *flatbuffers.Builder, id int32) {
	builder.PrependInt32Slot(2, id, 0)
}
func PartitionAddGroup(builder *flatbuffers.Builder, group flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(group), 0)
}
func PartitionAddReplicationFactor(builder *flatbuffers.Builder, replicationFactor int32) {
	builder.PrependInt32Slot(4, replicationFactor, 0)
}
func PartitionAddReplicas(builder *flatbuffers.Builder, replicas flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(replicas), 0)
}
func PartitionStartReplicasVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func PartitionAddLeader(builder *flatbuffers.Builder, leader flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(leader), 0)
}
func PartitionAddIsr(builder *flatbuffers.Builder, isr flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(isr), 0)
}
func PartitionStartIsrVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func PartitionAddLeaderEpoch(builder *flatbuffers.Builder, leaderEpoch uint64) {
	builder.PrependUint64Slot(8, leaderEpoch, 0)
}
func PartitionAddEpoch(builder *flatbuffers.Builder, epoch uint64) {
	builder.PrependUint64Slot(9, epoch, 0)
}
func PartitionEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type RaftJoinRequest struct {
	NodeID string
	NodeAddr string
}

func RaftJoinRequestPack(builder *flatbuffers.Builder, t *RaftJoinRequest) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	nodeIDOffset := builder.CreateString(t.NodeID)
	nodeAddrOffset := builder.CreateString(t.NodeAddr)
	RaftJoinRequestStart(builder)
	RaftJoinRequestAddNodeID(builder, nodeIDOffset)
	RaftJoinRequestAddNodeAddr(builder, nodeAddrOffset)
	return RaftJoinRequestEnd(builder)
}

func (rcv *RaftJoinRequestReceiver) UnPackTo(t *RaftJoinRequest) {
	t.NodeID = string(rcv.NodeID())
	t.NodeAddr = string(rcv.NodeAddr())
}

func (rcv *RaftJoinRequestReceiver) UnPack() *RaftJoinRequest {
	if rcv == nil { return nil }
	t := &RaftJoinRequest{}
	rcv.UnPackTo(t)
	return t
}

func (t *RaftJoinRequest) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(RaftJoinRequestPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *RaftJoinRequest) Unmarshal(data []byte) error {
	GetRootAsRaftJoinRequestReceiver(data, 0).UnPackTo(t)
	return nil
}

type RaftJoinRequestReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsRaftJoinRequestReceiver(buf []byte, offset flatbuffers.UOffsetT) *RaftJoinRequestReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &RaftJoinRequestReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *RaftJoinRequestReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *RaftJoinRequestReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *RaftJoinRequestReceiver) NodeID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *RaftJoinRequestReceiver) NodeAddr() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func RaftJoinRequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func RaftJoinRequestAddNodeID(builder *flatbuffers.Builder, nodeID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(nodeID), 0)
}
func RaftJoinRequestAddNodeAddr(builder *flatbuffers.Builder, nodeAddr flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(nodeAddr), 0)
}
func RaftJoinRequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type RaftJoinResponse struct {
	Error string
}

func RaftJoinResponsePack(builder *flatbuffers.Builder, t *RaftJoinResponse) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	errorOffset := builder.CreateString(t.Error)
	RaftJoinResponseStart(builder)
	RaftJoinResponseAddError(builder, errorOffset)
	return RaftJoinResponseEnd(builder)
}

func (rcv *RaftJoinResponseReceiver) UnPackTo(t *RaftJoinResponse) {
	t.Error = string(rcv.Error())
}

func (rcv *RaftJoinResponseReceiver) UnPack() *RaftJoinResponse {
	if rcv == nil { return nil }
	t := &RaftJoinResponse{}
	rcv.UnPackTo(t)
	return t
}

func (t *RaftJoinResponse) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(RaftJoinResponsePack(b, t))
	return b.FinishedBytes(), nil
}

func (t *RaftJoinResponse) Unmarshal(data []byte) error {
	GetRootAsRaftJoinResponseReceiver(data, 0).UnPackTo(t)
	return nil
}

type RaftJoinResponseReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsRaftJoinResponseReceiver(buf []byte, offset flatbuffers.UOffsetT) *RaftJoinResponseReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &RaftJoinResponseReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *RaftJoinResponseReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *RaftJoinResponseReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *RaftJoinResponseReceiver) Error() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func RaftJoinResponseStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func RaftJoinResponseAddError(builder *flatbuffers.Builder, error flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(error), 0)
}
func RaftJoinResponseEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type MetadataSnapshot struct {
	Partitions []*Partition
}

func MetadataSnapshotPack(builder *flatbuffers.Builder, t *MetadataSnapshot) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	partitionsOffset := flatbuffers.UOffsetT(0)
	if t.Partitions != nil {
		partitionsLength := len(t.Partitions)
		partitionsOffsets := make([]flatbuffers.UOffsetT, partitionsLength)
		for j := 0; j < partitionsLength; j++ {
			partitionsOffsets[j] = PartitionPack(builder, t.Partitions[j])
		}
		MetadataSnapshotStartPartitionsVector(builder, partitionsLength)
		for j := partitionsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(partitionsOffsets[j])
		}
		partitionsOffset = builder.EndVector(partitionsLength)
	}
	MetadataSnapshotStart(builder)
	MetadataSnapshotAddPartitions(builder, partitionsOffset)
	return MetadataSnapshotEnd(builder)
}

func (rcv *MetadataSnapshotReceiver) UnPackTo(t *MetadataSnapshot) {
	partitionsLength := rcv.PartitionsLength()
	t.Partitions = make([]*Partition, partitionsLength)
	for j := 0; j < partitionsLength; j++ {
		x := PartitionReceiver{}
		rcv.Partitions(&x, j)
		t.Partitions[j] = x.UnPack()
	}
}

func (rcv *MetadataSnapshotReceiver) UnPack() *MetadataSnapshot {
	if rcv == nil { return nil }
	t := &MetadataSnapshot{}
	rcv.UnPackTo(t)
	return t
}

func (t *MetadataSnapshot) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(MetadataSnapshotPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *MetadataSnapshot) Unmarshal(data []byte) error {
	GetRootAsMetadataSnapshotReceiver(data, 0).UnPackTo(t)
	return nil
}

type MetadataSnapshotReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsMetadataSnapshotReceiver(buf []byte, offset flatbuffers.UOffsetT) *MetadataSnapshotReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &MetadataSnapshotReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *MetadataSnapshotReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *MetadataSnapshotReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *MetadataSnapshotReceiver) Partitions(obj *PartitionReceiver, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *MetadataSnapshotReceiver) PartitionsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func MetadataSnapshotStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func MetadataSnapshotAddPartitions(builder *flatbuffers.Builder, partitions flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(partitions), 0)
}
func MetadataSnapshotStartPartitionsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func MetadataSnapshotEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ReplicationRequest struct {
	ReplicaID string
	Offset int64
}

func ReplicationRequestPack(builder *flatbuffers.Builder, t *ReplicationRequest) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	replicaIDOffset := builder.CreateString(t.ReplicaID)
	ReplicationRequestStart(builder)
	ReplicationRequestAddReplicaID(builder, replicaIDOffset)
	ReplicationRequestAddOffset(builder, t.Offset)
	return ReplicationRequestEnd(builder)
}

func (rcv *ReplicationRequestReceiver) UnPackTo(t *ReplicationRequest) {
	t.ReplicaID = string(rcv.ReplicaID())
	t.Offset = rcv.Offset()
}

func (rcv *ReplicationRequestReceiver) UnPack() *ReplicationRequest {
	if rcv == nil { return nil }
	t := &ReplicationRequest{}
	rcv.UnPackTo(t)
	return t
}

func (t *ReplicationRequest) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(ReplicationRequestPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *ReplicationRequest) Unmarshal(data []byte) error {
	GetRootAsReplicationRequestReceiver(data, 0).UnPackTo(t)
	return nil
}

type ReplicationRequestReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsReplicationRequestReceiver(buf []byte, offset flatbuffers.UOffsetT) *ReplicationRequestReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ReplicationRequestReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ReplicationRequestReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ReplicationRequestReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ReplicationRequestReceiver) ReplicaID() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ReplicationRequestReceiver) Offset() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ReplicationRequestReceiver) MutateOffset(n int64) bool {
	return rcv._tab.MutateInt64Slot(6, n)
}

func ReplicationRequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func ReplicationRequestAddReplicaID(builder *flatbuffers.Builder, replicaID flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(replicaID), 0)
}
func ReplicationRequestAddOffset(builder *flatbuffers.Builder, offset int64) {
	builder.PrependInt64Slot(1, offset, 0)
}
func ReplicationRequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type LeaderEpochOffsetRequest struct {
	LeaderEpoch uint64
}

func LeaderEpochOffsetRequestPack(builder *flatbuffers.Builder, t *LeaderEpochOffsetRequest) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	LeaderEpochOffsetRequestStart(builder)
	LeaderEpochOffsetRequestAddLeaderEpoch(builder, t.LeaderEpoch)
	return LeaderEpochOffsetRequestEnd(builder)
}

func (rcv *LeaderEpochOffsetRequestReceiver) UnPackTo(t *LeaderEpochOffsetRequest) {
	t.LeaderEpoch = rcv.LeaderEpoch()
}

func (rcv *LeaderEpochOffsetRequestReceiver) UnPack() *LeaderEpochOffsetRequest {
	if rcv == nil { return nil }
	t := &LeaderEpochOffsetRequest{}
	rcv.UnPackTo(t)
	return t
}

func (t *LeaderEpochOffsetRequest) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(LeaderEpochOffsetRequestPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *LeaderEpochOffsetRequest) Unmarshal(data []byte) error {
	GetRootAsLeaderEpochOffsetRequestReceiver(data, 0).UnPackTo(t)
	return nil
}

type LeaderEpochOffsetRequestReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsLeaderEpochOffsetRequestReceiver(buf []byte, offset flatbuffers.UOffsetT) *LeaderEpochOffsetRequestReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &LeaderEpochOffsetRequestReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *LeaderEpochOffsetRequestReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *LeaderEpochOffsetRequestReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *LeaderEpochOffsetRequestReceiver) LeaderEpoch() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *LeaderEpochOffsetRequestReceiver) MutateLeaderEpoch(n uint64) bool {
	return rcv._tab.MutateUint64Slot(4, n)
}

func LeaderEpochOffsetRequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func LeaderEpochOffsetRequestAddLeaderEpoch(builder *flatbuffers.Builder, leaderEpoch uint64) {
	builder.PrependUint64Slot(0, leaderEpoch, 0)
}
func LeaderEpochOffsetRequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type LeaderEpochOffsetResponse struct {
	EndOffset int64
}

func LeaderEpochOffsetResponsePack(builder *flatbuffers.Builder, t *LeaderEpochOffsetResponse) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	LeaderEpochOffsetResponseStart(builder)
	LeaderEpochOffsetResponseAddEndOffset(builder, t.EndOffset)
	return LeaderEpochOffsetResponseEnd(builder)
}

func (rcv *LeaderEpochOffsetResponseReceiver) UnPackTo(t *LeaderEpochOffsetResponse) {
	t.EndOffset = rcv.EndOffset()
}

func (rcv *LeaderEpochOffsetResponseReceiver) UnPack() *LeaderEpochOffsetResponse {
	if rcv == nil { return nil }
	t := &LeaderEpochOffsetResponse{}
	rcv.UnPackTo(t)
	return t
}

func (t *LeaderEpochOffsetResponse) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(LeaderEpochOffsetResponsePack(b, t))
	return b.FinishedBytes(), nil
}

func (t *LeaderEpochOffsetResponse) Unmarshal(data []byte) error {
	GetRootAsLeaderEpochOffsetResponseReceiver(data, 0).UnPackTo(t)
	return nil
}

type LeaderEpochOffsetResponseReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsLeaderEpochOffsetResponseReceiver(buf []byte, offset flatbuffers.UOffsetT) *LeaderEpochOffsetResponseReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &LeaderEpochOffsetResponseReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *LeaderEpochOffsetResponseReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *LeaderEpochOffsetResponseReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *LeaderEpochOffsetResponseReceiver) EndOffset() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *LeaderEpochOffsetResponseReceiver) MutateEndOffset(n int64) bool {
	return rcv._tab.MutateInt64Slot(4, n)
}

func LeaderEpochOffsetResponseStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func LeaderEpochOffsetResponseAddEndOffset(builder *flatbuffers.Builder, endOffset int64) {
	builder.PrependInt64Slot(0, endOffset, 0)
}
func LeaderEpochOffsetResponseEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type PropagatedRequest struct {
	Op Op
	CreatePartitionOp *CreatePartitionOp
	ShrinkISROp *ShrinkISROp
	ReportLeaderOp *ReportLeaderOp
	ExpandISROp *ExpandISROp
}

func PropagatedRequestPack(builder *flatbuffers.Builder, t *PropagatedRequest) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	createPartitionOpOffset := CreatePartitionOpPack(builder, t.CreatePartitionOp)
	shrinkISROpOffset := ShrinkISROpPack(builder, t.ShrinkISROp)
	reportLeaderOpOffset := ReportLeaderOpPack(builder, t.ReportLeaderOp)
	expandISROpOffset := ExpandISROpPack(builder, t.ExpandISROp)
	PropagatedRequestStart(builder)
	PropagatedRequestAddOp(builder, t.Op)
	PropagatedRequestAddCreatePartitionOp(builder, createPartitionOpOffset)
	PropagatedRequestAddShrinkISROp(builder, shrinkISROpOffset)
	PropagatedRequestAddReportLeaderOp(builder, reportLeaderOpOffset)
	PropagatedRequestAddExpandISROp(builder, expandISROpOffset)
	return PropagatedRequestEnd(builder)
}

func (rcv *PropagatedRequestReceiver) UnPackTo(t *PropagatedRequest) {
	t.Op = rcv.Op()
	t.CreatePartitionOp = rcv.CreatePartitionOp(nil).UnPack()
	t.ShrinkISROp = rcv.ShrinkISROp(nil).UnPack()
	t.ReportLeaderOp = rcv.ReportLeaderOp(nil).UnPack()
	t.ExpandISROp = rcv.ExpandISROp(nil).UnPack()
}

func (rcv *PropagatedRequestReceiver) UnPack() *PropagatedRequest {
	if rcv == nil { return nil }
	t := &PropagatedRequest{}
	rcv.UnPackTo(t)
	return t
}

func (t *PropagatedRequest) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(PropagatedRequestPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *PropagatedRequest) Unmarshal(data []byte) error {
	GetRootAsPropagatedRequestReceiver(data, 0).UnPackTo(t)
	return nil
}

type PropagatedRequestReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsPropagatedRequestReceiver(buf []byte, offset flatbuffers.UOffsetT) *PropagatedRequestReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PropagatedRequestReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *PropagatedRequestReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PropagatedRequestReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *PropagatedRequestReceiver) Op() Op {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return Op(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *PropagatedRequestReceiver) MutateOp(n Op) bool {
	return rcv._tab.MutateByteSlot(4, byte(n))
}

func (rcv *PropagatedRequestReceiver) CreatePartitionOp(obj *CreatePartitionOpReceiver) *CreatePartitionOpReceiver {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(CreatePartitionOpReceiver)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *PropagatedRequestReceiver) ShrinkISROp(obj *ShrinkISROpReceiver) *ShrinkISROpReceiver {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ShrinkISROpReceiver)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *PropagatedRequestReceiver) ReportLeaderOp(obj *ReportLeaderOpReceiver) *ReportLeaderOpReceiver {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ReportLeaderOpReceiver)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *PropagatedRequestReceiver) ExpandISROp(obj *ExpandISROpReceiver) *ExpandISROpReceiver {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ExpandISROpReceiver)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func PropagatedRequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func PropagatedRequestAddOp(builder *flatbuffers.Builder, op Op) {
	builder.PrependByteSlot(0, byte(op), 0)
}
func PropagatedRequestAddCreatePartitionOp(builder *flatbuffers.Builder, createPartitionOp flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(createPartitionOp), 0)
}
func PropagatedRequestAddShrinkISROp(builder *flatbuffers.Builder, shrinkISROp flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(shrinkISROp), 0)
}
func PropagatedRequestAddReportLeaderOp(builder *flatbuffers.Builder, reportLeaderOp flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(reportLeaderOp), 0)
}
func PropagatedRequestAddExpandISROp(builder *flatbuffers.Builder, expandISROp flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(expandISROp), 0)
}
func PropagatedRequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Error struct {
	Code uint32
	Msg string
}

func ErrorPack(builder *flatbuffers.Builder, t *Error) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	msgOffset := builder.CreateString(t.Msg)
	ErrorStart(builder)
	ErrorAddCode(builder, t.Code)
	ErrorAddMsg(builder, msgOffset)
	return ErrorEnd(builder)
}

func (rcv *ErrorReceiver) UnPackTo(t *Error) {
	t.Code = rcv.Code()
	t.Msg = string(rcv.Msg())
}

func (rcv *ErrorReceiver) UnPack() *Error {
	if rcv == nil { return nil }
	t := &Error{}
	rcv.UnPackTo(t)
	return t
}

func (t *Error) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(ErrorPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *Error) Unmarshal(data []byte) error {
	GetRootAsErrorReceiver(data, 0).UnPackTo(t)
	return nil
}

type ErrorReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsErrorReceiver(buf []byte, offset flatbuffers.UOffsetT) *ErrorReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ErrorReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ErrorReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ErrorReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ErrorReceiver) Code() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ErrorReceiver) MutateCode(n uint32) bool {
	return rcv._tab.MutateUint32Slot(4, n)
}

func (rcv *ErrorReceiver) Msg() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func ErrorStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func ErrorAddCode(builder *flatbuffers.Builder, code uint32) {
	builder.PrependUint32Slot(0, code, 0)
}
func ErrorAddMsg(builder *flatbuffers.Builder, msg flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(msg), 0)
}
func ErrorEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type PropagatedResponse struct {
	Op Op
	Error *Error
}

func PropagatedResponsePack(builder *flatbuffers.Builder, t *PropagatedResponse) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	errorOffset := ErrorPack(builder, t.Error)
	PropagatedResponseStart(builder)
	PropagatedResponseAddOp(builder, t.Op)
	PropagatedResponseAddError(builder, errorOffset)
	return PropagatedResponseEnd(builder)
}

func (rcv *PropagatedResponseReceiver) UnPackTo(t *PropagatedResponse) {
	t.Op = rcv.Op()
	t.Error = rcv.Error(nil).UnPack()
}

func (rcv *PropagatedResponseReceiver) UnPack() *PropagatedResponse {
	if rcv == nil { return nil }
	t := &PropagatedResponse{}
	rcv.UnPackTo(t)
	return t
}

func (t *PropagatedResponse) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(PropagatedResponsePack(b, t))
	return b.FinishedBytes(), nil
}

func (t *PropagatedResponse) Unmarshal(data []byte) error {
	GetRootAsPropagatedResponseReceiver(data, 0).UnPackTo(t)
	return nil
}

type PropagatedResponseReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsPropagatedResponseReceiver(buf []byte, offset flatbuffers.UOffsetT) *PropagatedResponseReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PropagatedResponseReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *PropagatedResponseReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PropagatedResponseReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *PropagatedResponseReceiver) Op() Op {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return Op(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *PropagatedResponseReceiver) MutateOp(n Op) bool {
	return rcv._tab.MutateByteSlot(4, byte(n))
}

func (rcv *PropagatedResponseReceiver) Error(obj *ErrorReceiver) *ErrorReceiver {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ErrorReceiver)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func PropagatedResponseStart(builder *flatbuffers.Builder) {
	builder.StartObject(6)
}
func PropagatedResponseAddOp(builder *flatbuffers.Builder, op Op) {
	builder.PrependByteSlot(0, byte(op), 0)
}
func PropagatedResponseAddError(builder *flatbuffers.Builder, error flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(error), 0)
}
func PropagatedResponseEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ServerInfoRequest struct {
	Id string
}

func ServerInfoRequestPack(builder *flatbuffers.Builder, t *ServerInfoRequest) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	idOffset := builder.CreateString(t.Id)
	ServerInfoRequestStart(builder)
	ServerInfoRequestAddId(builder, idOffset)
	return ServerInfoRequestEnd(builder)
}

func (rcv *ServerInfoRequestReceiver) UnPackTo(t *ServerInfoRequest) {
	t.Id = string(rcv.Id())
}

func (rcv *ServerInfoRequestReceiver) UnPack() *ServerInfoRequest {
	if rcv == nil { return nil }
	t := &ServerInfoRequest{}
	rcv.UnPackTo(t)
	return t
}

func (t *ServerInfoRequest) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(ServerInfoRequestPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *ServerInfoRequest) Unmarshal(data []byte) error {
	GetRootAsServerInfoRequestReceiver(data, 0).UnPackTo(t)
	return nil
}

type ServerInfoRequestReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsServerInfoRequestReceiver(buf []byte, offset flatbuffers.UOffsetT) *ServerInfoRequestReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ServerInfoRequestReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ServerInfoRequestReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ServerInfoRequestReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ServerInfoRequestReceiver) Id() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func ServerInfoRequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func ServerInfoRequestAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(id), 0)
}
func ServerInfoRequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ServerInfoResponse struct {
	Id string
	Host string
	Port int32
}

func ServerInfoResponsePack(builder *flatbuffers.Builder, t *ServerInfoResponse) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	idOffset := builder.CreateString(t.Id)
	hostOffset := builder.CreateString(t.Host)
	ServerInfoResponseStart(builder)
	ServerInfoResponseAddId(builder, idOffset)
	ServerInfoResponseAddHost(builder, hostOffset)
	ServerInfoResponseAddPort(builder, t.Port)
	return ServerInfoResponseEnd(builder)
}

func (rcv *ServerInfoResponseReceiver) UnPackTo(t *ServerInfoResponse) {
	t.Id = string(rcv.Id())
	t.Host = string(rcv.Host())
	t.Port = rcv.Port()
}

func (rcv *ServerInfoResponseReceiver) UnPack() *ServerInfoResponse {
	if rcv == nil { return nil }
	t := &ServerInfoResponse{}
	rcv.UnPackTo(t)
	return t
}

func (t *ServerInfoResponse) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(ServerInfoResponsePack(b, t))
	return b.FinishedBytes(), nil
}

func (t *ServerInfoResponse) Unmarshal(data []byte) error {
	GetRootAsServerInfoResponseReceiver(data, 0).UnPackTo(t)
	return nil
}

type ServerInfoResponseReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsServerInfoResponseReceiver(buf []byte, offset flatbuffers.UOffsetT) *ServerInfoResponseReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ServerInfoResponseReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ServerInfoResponseReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ServerInfoResponseReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ServerInfoResponseReceiver) Id() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ServerInfoResponseReceiver) Host() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ServerInfoResponseReceiver) Port() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ServerInfoResponseReceiver) MutatePort(n int32) bool {
	return rcv._tab.MutateInt32Slot(8, n)
}

func ServerInfoResponseStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func ServerInfoResponseAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(id), 0)
}
func ServerInfoResponseAddHost(builder *flatbuffers.Builder, host flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(host), 0)
}
func ServerInfoResponseAddPort(builder *flatbuffers.Builder, port int32) {
	builder.PrependInt32Slot(2, port, 0)
}
func ServerInfoResponseEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type PartitionStatusRequest struct {
	Stream string
	Partition int32
}

func PartitionStatusRequestPack(builder *flatbuffers.Builder, t *PartitionStatusRequest) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	streamOffset := builder.CreateString(t.Stream)
	PartitionStatusRequestStart(builder)
	PartitionStatusRequestAddStream(builder, streamOffset)
	PartitionStatusRequestAddPartition(builder, t.Partition)
	return PartitionStatusRequestEnd(builder)
}

func (rcv *PartitionStatusRequestReceiver) UnPackTo(t *PartitionStatusRequest) {
	t.Stream = string(rcv.Stream())
	t.Partition = rcv.Partition()
}

func (rcv *PartitionStatusRequestReceiver) UnPack() *PartitionStatusRequest {
	if rcv == nil { return nil }
	t := &PartitionStatusRequest{}
	rcv.UnPackTo(t)
	return t
}

func (t *PartitionStatusRequest) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(PartitionStatusRequestPack(b, t))
	return b.FinishedBytes(), nil
}

func (t *PartitionStatusRequest) Unmarshal(data []byte) error {
	GetRootAsPartitionStatusRequestReceiver(data, 0).UnPackTo(t)
	return nil
}

type PartitionStatusRequestReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsPartitionStatusRequestReceiver(buf []byte, offset flatbuffers.UOffsetT) *PartitionStatusRequestReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PartitionStatusRequestReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *PartitionStatusRequestReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PartitionStatusRequestReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *PartitionStatusRequestReceiver) Stream() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *PartitionStatusRequestReceiver) Partition() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *PartitionStatusRequestReceiver) MutatePartition(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func PartitionStatusRequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func PartitionStatusRequestAddStream(builder *flatbuffers.Builder, stream flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(stream), 0)
}
func PartitionStatusRequestAddPartition(builder *flatbuffers.Builder, partition int32) {
	builder.PrependInt32Slot(1, partition, 0)
}
func PartitionStatusRequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type PartitionStatusResponse struct {
	Exists bool
	IsLeader bool
}

func PartitionStatusResponsePack(builder *flatbuffers.Builder, t *PartitionStatusResponse) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	PartitionStatusResponseStart(builder)
	PartitionStatusResponseAddExists(builder, t.Exists)
	PartitionStatusResponseAddIsLeader(builder, t.IsLeader)
	return PartitionStatusResponseEnd(builder)
}

func (rcv *PartitionStatusResponseReceiver) UnPackTo(t *PartitionStatusResponse) {
	t.Exists = rcv.Exists()
	t.IsLeader = rcv.IsLeader()
}

func (rcv *PartitionStatusResponseReceiver) UnPack() *PartitionStatusResponse {
	if rcv == nil { return nil }
	t := &PartitionStatusResponse{}
	rcv.UnPackTo(t)
	return t
}

func (t *PartitionStatusResponse) Marshal() ([]byte, error) {
	b := flatbuffers.NewBuilder(0)
	b.Finish(PartitionStatusResponsePack(b, t))
	return b.FinishedBytes(), nil
}

func (t *PartitionStatusResponse) Unmarshal(data []byte) error {
	GetRootAsPartitionStatusResponseReceiver(data, 0).UnPackTo(t)
	return nil
}

type PartitionStatusResponseReceiver struct {
	_tab flatbuffers.Table
}

func GetRootAsPartitionStatusResponseReceiver(buf []byte, offset flatbuffers.UOffsetT) *PartitionStatusResponseReceiver {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &PartitionStatusResponseReceiver{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *PartitionStatusResponseReceiver) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *PartitionStatusResponseReceiver) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *PartitionStatusResponseReceiver) Exists() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *PartitionStatusResponseReceiver) MutateExists(n bool) bool {
	return rcv._tab.MutateBoolSlot(4, n)
}

func (rcv *PartitionStatusResponseReceiver) IsLeader() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *PartitionStatusResponseReceiver) MutateIsLeader(n bool) bool {
	return rcv._tab.MutateBoolSlot(6, n)
}

func PartitionStatusResponseStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func PartitionStatusResponseAddExists(builder *flatbuffers.Builder, exists bool) {
	builder.PrependBoolSlot(0, exists, false)
}
func PartitionStatusResponseAddIsLeader(builder *flatbuffers.Builder, isLeader bool) {
	builder.PrependBoolSlot(1, isLeader, false)
}
func PartitionStatusResponseEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
